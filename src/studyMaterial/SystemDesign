Design Twitter:
===============

Use cases / Core features:
Lets define twitter to its MVP (Minimum Viable Product).
1. Users can follow other users
2. Users can read other user's feed whom they follow

Data model:
User and Feed objects
Relation between users - one user following other user
Relation between users and feeds - every feed has a owner user

Server feed:
List tweets from users they follow with the most recent at the top. Don't have to list all the tweets. 
Say top 20 at a time - Pagination. The feed could be ranked based on time or other personal traits like
user's common interests. Tweets from users from the same location. Tweets from users with most common friends.
Tweets from famous celebrities followed by the user.

@ and retweet feature. Any feed with the user mentioned using @ also needs to be listed in the feed.
Retweet also include the owner user id to be shown when retweeted.

Talk about the below features:
1. Trending topics
	- Generate and rank the top trending topics. Could be based on frequency of hash tags,
	Search query terms, pick common words/phrases from the top 'N' news topics in the last n hours.
	-Ranking the topics could be based on user's interests (based on favorites, retweets and comments) 
2. Moments
	- Organize the trending topics into pre-defined categories like news, sports, fun etc.
	- List the trending topics and organize them into categories. Rank the tweets in each category.
3. Whom to follow / Recommendation system
	- Recommendation system based on machine learning to recommend other users to follow
	- Provide following graphs users 2 to 3 steps away with common friends, common interests, common location,
	Users with more followers could be ranked higher while listing
	- Also include famous personalities with large number of followers in user's choice of interest
4. Search for feed
	- Weight given to certain social aspects when searching and listing search queries

How to detect fake users  -machine learning systems based on number of followers, tweets and amount of time logged in etc.

Design Youtube:
===============
1. Storage and data model - Youtube uses MySql DB
	- User and video tables
	- User can have login and personal details - these can be 2 separate tables
	- Video contains video metadata, likes count, view count, shares etc.
	- Relation bw users and videos - video uploaded by user, video liked by user
	
	Scaling the DB
	- Start with a single server and scale as needed as features and use case keep changing
	- Master slave model - writes to master, reads from multiple slaves
	- Sharding the DB based on user's location, route the request to the appropriate DB
	
2. Video and image storage
	- Youtube has more images than videos - multiple size images and thumbnails
3. Popular vs long tailed videos
	- Popular videos can be hosted on CDN (Content Delivery Network - nw of proxy servers around the world)
	- Long tailed videos are videos with less view counts per day (less popular), these can be stored closer to the user
	to enhance performance
	- Performance can be optimized by having separate clusters for videos and general data
4. Web server
	- a bunch of web servers behind a load balancer
	- These servers deal with authentication, session management and less heavy business logic
	- More business heavy logic are routed to dedicated servers like recommendation server, video storage server
	- A cache at the web server level and also a cache at the front end will enhance the performance for the user
5. Security
	- We also need to handle hacking view counts - These can be detected by looking at the origin IP,
	also view counts need to go with view time and other statistics like comments, likes etc. With historical data available,
	it wouldn't be difficult to predict usage patterns and detect fake view counts - a dedicated machine learning system to detect
	video hacking could be used

Design chat application - like whatsapp:
========================================
1. Use case
	-User A sends a msg to User B
		- User A sends a msg to chat server
		- Server sends an acknowledgement (a single tick mark)
		- Now there are 2 cases:
			- B is online, server sends a msg to B
			- B is offline, a push notification is sent to B
		- B sends an acknowledgement to the server
		- server sends an acknowledgement to A that B has received (2 tick marks)
			
			
2. To enhance performance - a HTTP persistent connection can be established from the recipient to the server. The recipient
establishes a connection and waits for a response from the server. Recipient re-establishes a connection on timeout or interruption.
This enhances the performance, rather than spawn a new process/thread and generate a new HTTP request and close the connection
after the request.

3. Detecting online users - Server can send a notification when any of the friends of a user changes the status. Can be optimized 
to send status online of the user has been online for more than say 5 mins.

A simple flow of events:
-User registers for his account 
-User logs in with his credentials 
-User adds/edits/deletes contacts 
-User sends message to his contact 
-User receives message from his contact 
-User logs out of the server 

Server side: 
-User account added to account-list 
-User credentials verified while logging in and session created if success 
-User contacts are managed with three operations addition, deletion, modification 
-User message is queued in his contacts message queue 
-User is delivered message from his queue if any 
-User session is deleted

Data structures:
enum Status{offline, online, away}
struct Message{ User from_user; User to_user; String post_message;}
class User {Status type; Message posts[]; sendMessage(); addGroup(); updateStatus(); createGroup(); } 
struct Group { Message posts[]; User list[];}

Design an eCommerce website like amazon:
========================================
1. Data model
	-Users
		- user details of the purchaser
	-Product (Can have a product Category)
		- product details inlcuding category and price
	-Order
		- shopping cart oreder details like amount, quantity, total price
		
	Relational DB vs NoSQL DB
		-Relational DB like MySQL would need a product table. Product table would have a number of 
		columns each representing a attribute of a product.
		-NoSQL has the advantage of specifying only the details needed for that particular product. 
		Other attributes of the product can be null. Details can be stored something like a JSON.
		
2. Concurrency, consistency and Availability are very important when scaling an eCommerce site
	-Concurrency - suppose there is a single copy of the book remaining. How to ensure concurrency if
	2 users are trying to buy the same.
		- Optimistic concurrency control (OCC) - Lock the entire row for the transaction.
		This approach is better if there are a lot of conflicts.
		- Pessimistic concurrency control (PCC) - Check the value during the start of the transaction and 
		check again before committing the transaction, if the value has changed, roll-back and start over.
		
		For a site like amazon with so many products and categories, there being a conflict is less likely, 
		PCC is better suited here.
		
	-Consistency and availability go hand in hand. We need thousands of resources/servers for better availability.
	Increased availability reduces the consistency as the values need to be consistent across all resources.
		-Strong consistency - The updates are atomic across all resources like in a single system.
		-Weak consistency - The updates are not consistent across resources. In this case, it is upto
		the clients to make a decision. If a shopping cart has different values across different hosts,
		it might be more beneficial to pick the cart with more items.
		-Eventual consistency - The updates become consistent eventually over time but maybe inconsistent
		in the mean time.

Shopping-cart data structure:
ShoppingCart
	List<ItemOrder> items;
	add(ItemOrder)
	remove(ItemOrder)
	applyCoupan(Coupan)
	getTotal()	

ItemOrder
	Item item;
	int quantity
	double price;
	getPrice()
	getQuantity()
	changeQuantity();

Enum ItemTypes\ or Category

Item
	String name;
	ItemTypes type;
	double price;
	String itemID;
	getName()
	getItemID();
	getItemPrice();

Design HitCounter - Number of visitors in the last 1 min:
=========================================================
Simplest approach:
	Log users in a DB along with timestamp, then filter and return count of visitors in the last 1m - O(n),
	n is the number of visitors
	A simple optimization would be to sort based on timestamp

A better approach would be to maintain a queue (linkedlist) and keep appending users to the list, when the timestamp
of first entry in the queue is > 1m, remove the first entry from list. Time efficiency is optimized to O(1) put space 
efficiency still has a list of users in the queue. We could just store the timestamp and not the user object to optimize 
space.

Similar to the moving average problem below:
public class MovingAverage {
    private int size;
    private int sum;
    private Queue<Integer> window;

    public MovingAverage(int size) {
        this.size = size;
        this.sum = 0;
        this.window = new ArrayDeque<>();
    }

    public double next(int val) {
        window.offer(val);
        if (window.size() > size) {
            sum -= window.poll();
        }
        sum += val;
        return (double) sum / window.size();
    }
}

An even better space efficiency would be if we can reduce accuracy by having visitor count upto the last second.
That way space is optimized to constant as shown in the code below:
public class HitCounter {
    int[] hits;
    int[] times;

    public HitCounter() {
        hits = new int[300];
        times = new int[300];
    }

    public void hit(int time) {
        int index = time % 300;
        if (times[index] != time) {
            times[index] = time;
            hits[index] = 1;
        } else {
            hits[index]++;
        }
    }

    public int getHits(int time) {
        int count = 0;

        for (int i = 0; i < 300; i++) {
            if (time - times[i] < 300) {
                count += hits[i];
            }
        }

        return count;
    }
}

For a distributed system with a large number of requests, a lock could be used but that reduces the performace. A better approach
would be to distribute the counters across hosts and then add them back.


Design ticketmaster:
====================
Design a ticket sales site where people can buy tickets to sporting events and concerts.

MVP:
User case:
1. User looks at the list of events in a time range - say 3 months
2. User selects an event
3. User chooses a seat from amongst the available
4. User purchases the ticket to the event

User's browser  --> Web server ---> DB

Data Model:
	-Users
		-userId
		-userName
		-userCreditCard
		-userCreditCardExpiry
		-userCVV
	-Events
		-eventId
		-eventDate
		-eventVenue
		-eventDescription
	-Seats
		-seatId
		-seatSection
		-seatRow
		-seatNumber
		-seatPrice
		-seatAvailable
		-eventId
	-Purchases
		-userId
		-eventId
		-seatId

Concurrency: What happens if 2 users book the same seat to the same event at the same time
Use a ACID DB. Check for seat availability at the start of the transaction. Before committing the transaction
check if the value is the same. If the seat is no longer available, roll-back and request to choose another seat.

We could also block the seat on a first come first server basis for a small time period (say 5 mins) in order to
server the user who blocked the seat first.

Scaling:
Load balancer (Backup Load Balancer) ---> a Number of web servers ---> Cache (DB optimization) ---> DB (backup DB)

Design order tracking system like doordash:
===========================================
Design an order tracking system using the below constraints. 

Once an order is received, it will be assigned to a delivery boy and sends notification at every stage of the order
such as order received with expected time of delivery, delivery boy assigned, order picked up, order delivered. 

The main idea is to implement the Observable architecture.
We need to create OrderManager Class that observe Order Class for status changes.


package com.cracking.amazon;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;

public class AmazonOrders {
	
	
	public static interface Observer<T> {
		public void onChange(T subject);
	}
	
	public static interface Subject<T>{
		public boolean registerObserver(Observer<T> observer);
		public void notifyAllObservers();
		public boolean deleteObserver(Observer<T> observer);
	}
	
	public static enum OrderStatus {
		Received("Received"),
		Assigned("Assigned"),
		Delivered("Delivered"),
		PickedUp("PickedUp");
		
		public String description;
		
		OrderStatus(String description) {
			this.description = description;
		}
	}
	
	public static class DeliveryBoy {
		private int id;
		private String name;
		
		public DeliveryBoy(int id, String name){
			this.id = id;
			this.name = name;
		}
	}
	
	public static class Order implements Subject<Order> {
		
		private ArrayList<Observer<Order>> observers;
		private int id;
		private Date expectedTime;
		private OrderStatus status;
		private DeliveryBoy deliveryBoy;
		
		public Order(int id, Date expectedTime){
			this.observers = new ArrayList<Observer<Order>>();
			this.id = id;
			this.expectedTime = expectedTime;
		}
		
		public int getId(){
			return this.id;
		}
		
		public void assignDeliveryBoy(DeliveryBoy deliveryBoy) {
			this.deliveryBoy = deliveryBoy;
			this.setStatus(OrderStatus.Assigned);
		}
		
		public void setStatus(OrderStatus status) {
			this.status = status;
			this.notifyAllObservers();
		}

		@Override
		public boolean registerObserver(Observer<Order> observer) {
			if(!this.observers.contains(observer)) {
				this.observers.add(observer);
				return true;
			}
			return false;
		}

		@Override
		public boolean deleteObserver(Observer<Order> observer) {
			return this.observers.remove(observer);
		}

		@Override
		public void notifyAllObservers() {
			for(Observer<Order> observer:this.observers) {
				observer.onChange(this);
			}
		}
	}
	
	public static class OrderManager implements Observer<Order> {
		
		private ArrayList<Order> orders;
		
		public OrderManager() {
			this.orders = new ArrayList<Order>();
		}
		
		public boolean addOrder(Order order) {
			if(!this.orders.contains(order)){
				this.orders.add(order);
				order.registerObserver(this);
				order.setStatus(OrderStatus.Received);
				return true;
			}
			
			return false;
		}

		@Override
		public void onChange(Order subject) {
			// TODO Auto-generated method stub
			String msg = String.format("Order #%d status changed - %s", 
					subject.getId(),
					subject.status.description);
			System.out.println(msg);
		}
		
	}
	
	public static void main(String[] args) {
		OrderManager orderManager = new OrderManager();
		DeliveryBoy mainDeliveryBoy = new DeliveryBoy(100, "Main Delivery Boy");
		
		Calendar cal = Calendar.getInstance(); 
		cal.setTime(new Date());
		cal.add(Calendar.DATE, 2);
		Date date1 = cal.getTime();

		Order order1 = new Order(1, date1);
		
		//Order Received
		orderManager.addOrder(order1);
		
		//Order Assigned
		order1.assignDeliveryBoy(mainDeliveryBoy);
		
		//Order Delivered
		order1.setStatus(OrderStatus.Delivered);
		
		//Picked Up
		order1.setStatus(OrderStatus.PickedUp);
		
	}

}


	
	



	
	



			
	
	





